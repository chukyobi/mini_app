import React, { useRef, useState, useCallback, useEffect } from 'react';

var ScratchCard = function ScratchCard(_ref) {
  var _ref$width = _ref.width,
    width = _ref$width === void 0 ? 300 : _ref$width,
    _ref$height = _ref.height,
    height = _ref$height === void 0 ? 150 : _ref$height,
    _ref$image = _ref.image,
    image = _ref$image === void 0 ? '' : _ref$image,
    _ref$finishPercent = _ref.finishPercent,
    finishPercent = _ref$finishPercent === void 0 ? 60 : _ref$finishPercent,
    _ref$onComplete = _ref.onComplete,
    onComplete = _ref$onComplete === void 0 ? function () {} : _ref$onComplete,
    _ref$brushSize = _ref.brushSize,
    brushSize = _ref$brushSize === void 0 ? 30 : _ref$brushSize,
    children = _ref.children;
  var canvasRef = useRef(null);
  var isDrawingRef = useRef(false);
  var lastPositionRef = useRef({
    x: 0,
    y: 0
  });
  var autoRevealedRef = useRef(false);
  var _useState = useState(false),
    canvasLoaded = _useState[0],
    setCanvasLoaded = _useState[1];
  var getMousePosition = function getMousePosition(canvas, event) {
    var rect = canvas.getBoundingClientRect();
    return {
      x: (event.clientX || event.touches[0].clientX) - rect.left,
      y: (event.clientY || event.touches[0].clientY) - rect.top
    };
  };
  var startDrawing = useCallback(function (event) {
    isDrawingRef.current = true;
    lastPositionRef.current = getMousePosition(canvasRef.current, event);
  }, []);
  var draw = useCallback(function (event) {
    if (!isDrawingRef.current || autoRevealedRef.current || !canvasRef.current) return;
    var ctx = canvasRef.current.getContext('2d');
    var newPosition = getMousePosition(canvasRef.current, event);
    if (ctx) {
      ctx.globalCompositeOperation = 'destination-out';
      ctx.lineWidth = brushSize;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(lastPositionRef.current.x, lastPositionRef.current.y);
      ctx.lineTo(newPosition.x, newPosition.y);
      ctx.stroke();
      lastPositionRef.current = newPosition;
      checkReveal(ctx);
    }
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [brushSize]);
  var checkReveal = useCallback(function (ctx) {
    var imageData = ctx.getImageData(0, 0, width, height);
    var pixels = imageData.data;
    var transparentPixels = 0;
    for (var i = 0; i < pixels.length; i += 4) {
      if (pixels[i + 3] === 0) transparentPixels++;
    }
    var totalPixels = width * height;
    var currentPercentage = transparentPixels / totalPixels * 100;
    if (currentPercentage >= finishPercent && !autoRevealedRef.current) {
      autoRevealedRef.current = true;
      ctx.clearRect(0, 0, width, height); // Clear the canvas here
      onComplete(); // Call the onComplete callback
    }
  }, [finishPercent, width, height, onComplete]);
  var stopDrawing = useCallback(function () {
    isDrawingRef.current = false;
  }, []);
  useEffect(function () {
    if (canvasRef.current) {
      var canvas = canvasRef.current;
      canvas.width = width;
      canvas.height = height;
      var ctx = canvas.getContext('2d');
      if (ctx) {
        if (image) {
          var backgroundImage = new Image();
          backgroundImage.crossOrigin = 'anonymous';
          backgroundImage.src = image;
          backgroundImage.onload = function () {
            ctx.drawImage(backgroundImage, 0, 0, width, height);
            ctx.globalCompositeOperation = 'source-over';
            setCanvasLoaded(true); // Set canvasLoaded to true when the image is loaded
          };

          backgroundImage.onerror = function () {
            console.error('Failed to load the image with CORS policy');
          };
        } else {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, width, height);
          setCanvasLoaded(true); // Set canvasLoaded to true when there is no image
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);
      }
      return function () {
        canvas.removeEventListener('mousedown', startDrawing);
        canvas.removeEventListener('mousemove', draw);
        canvas.removeEventListener('mouseup', stopDrawing);
        canvas.removeEventListener('mouseout', stopDrawing);
        canvas.removeEventListener('touchstart', startDrawing);
        canvas.removeEventListener('touchmove', draw);
        canvas.removeEventListener('touchend', stopDrawing);
      };
    }
    return function () {};
  }, [startDrawing, draw, stopDrawing, image, width, height]);
  return React.createElement("div", {
    style: {
      position: 'relative',
      width: width,
      height: height
    }
  }, React.createElement("div", {
    style: {
      position: 'absolute',
      zIndex: 999,
      width: width,
      height: height
    }
  }, React.createElement("canvas", {
    ref: canvasRef
  })), canvasLoaded && React.createElement("div", {
    style: {
      position: 'relative',
      width: width,
      height: height
    }
  }, children));
};

export { ScratchCard };
//# sourceMappingURL=next-scratchcard.esm.js.map
